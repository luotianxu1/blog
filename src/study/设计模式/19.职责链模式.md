---
title: 职责链模式
icon: 设计模式
order: 19
date: 2024-06-03
category:
    - 设计模式
tag:
    - 职责链模式
---

- 使多个对象都有机会处理请求，从而避免了请求的发送者与多个接收者直接的耦合关系，将这些接收者链接成一条链，顺着这条链传递该请求，直到找到能处理该请求的对象。

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <input type="text" id="input" />
        <button id="btn">注册</button>
        <script>
            let btn = document.getElementById('btn')
            btn.addEventListener('click', () => {
                let input = document.getElementById('input')
                checks.check()
            })

            function checkEmpty() {
                let input = document.getElementById('input')
                if (input.value.length === 0) {
                    console.log('这里不能为空')
                    return
                }
                return 'next'
            }

            function checkNumber() {
                let input = document.getElementById('input')
                if (Number.isNaN(+input.value)) {
                    console.log('这里必须是数字')
                    return
                }
                return 'next'
            }

            function checkLength() {
                let input = document.getElementById('input')
                if (input.value.length < 6) {
                    console.log('这里必须大于6个数字')
                    return
                }
                return 'next'
            }

            class Chain {
                constructor(fn) {
                    this.checkRule = fn
                    this.nextRule = null
                }

                addRule(nextRule) {
                    this.nextRule = new Chain(nextRule)
                    return this.nextRule
                }

                check() {
                    this.checkRule() === 'next' ? this.nextRule.check() : null
                }

                end() {
                    this.nextRule = {
                        check: () => 'end',
                    }
                }
            }

            const checks = new Chain(checkEmpty)
            checks
                .addRule(checkNumber)
                .addRule(checkNumber)
                .addRule(checkLength)
                .end()
        </script>
    </body>
</html>
```

- 优点
  - 符合单一职责，使每个方法中都只有一个职责
  - 符合开放封闭原则，在需求增加时可以很方便的扩充新的责任
  - 使用的时候不需要知道谁才是真正处理方法，减少大量的if或switch语法
- 缺点
  - 团队成员需要对责任链存在共识，否则当看到一个方法莫名其妙的返回一个next时一定会很奇怪
  - 出错时不好排查问题，因为不知道到底在哪个责任中出的错，需要从链头开始往后找
